import { 
  type User, type InsertUser,
  type Recipe, type InsertRecipe, type RecipeWithDetails,
  type Ingredient, type InsertIngredient,
  type Favorite, type InsertFavorite,
  type SharedRecipe, type InsertSharedRecipe,
  type RecipePhoto, type InsertRecipePhoto
} from "@shared/schema";

export interface IStorage {
  // Users
  getUser(id: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Recipes
  getRecipe(id: string, userId?: string): Promise<RecipeWithDetails | undefined>;
  getRecipesByUser(userId: string): Promise<RecipeWithDetails[]>;
  getPublicRecipes(userId?: string): Promise<RecipeWithDetails[]>;
  getFavoritedRecipes(userId: string): Promise<RecipeWithDetails[]>;
  getSharedRecipes(email: string): Promise<RecipeWithDetails[]>;
  createRecipe(recipe: InsertRecipe): Promise<Recipe>;
  updateRecipe(id: string, recipe: Partial<InsertRecipe>): Promise<Recipe>;
  deleteRecipe(id: string): Promise<void>;

  // Ingredients
  createIngredient(ingredient: InsertIngredient): Promise<Ingredient>;
  updateIngredient(id: string, ingredient: Partial<InsertIngredient>): Promise<Ingredient>;
  deleteIngredient(id: string): Promise<void>;
  deleteIngredientsByRecipe(recipeId: string): Promise<void>;

  // Favorites
  toggleFavorite(userId: string, recipeId: string): Promise<{ isFavorited: boolean }>;
  getFavoriteCount(recipeId: string): Promise<number>;

  // Sharing
  shareRecipe(recipeId: string, email: string): Promise<SharedRecipe>;
  
  // Photos
  createRecipePhoto(photo: InsertRecipePhoto): Promise<RecipePhoto>;
  deleteRecipePhoto(id: string): Promise<void>;
}

export class MemStorage implements IStorage {
  private users: Map<string, User> = new Map();
  private recipes: Map<string, Recipe> = new Map();
  private ingredients: Map<string, Ingredient> = new Map();
  private favorites: Map<string, Favorite> = new Map();
  private sharedRecipes: Map<string, SharedRecipe> = new Map();
  private recipePhotos: Map<string, RecipePhoto> = new Map();

  private idCounter = 1;

  private generateId(): string {
    return String(this.idCounter++);
  }

  // Users
  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(u => u.email === email);
  }

  async createUser(user: InsertUser): Promise<User> {
    const newUser: User = {
      ...user,
      createdAt: new Date(),
    };
    this.users.set(user.id, newUser);
    return newUser;
  }

  // Recipes
  async getRecipe(id: string, userId?: string): Promise<RecipeWithDetails | undefined> {
    const recipe = this.recipes.get(id);
    if (!recipe) return undefined;

    const recipeIngredients = Array.from(this.ingredients.values())
      .filter(i => i.recipeId === id)
      .sort((a, b) => a.order - b.order);

    const recipePhotosData = Array.from(this.recipePhotos.values())
      .filter(p => p.recipeId === id);

    const author = await this.getUser(recipe.userId);
    const favoriteCount = await this.getFavoriteCount(id);

    let isFavorited = false;
    if (userId) {
      isFavorited = Array.from(this.favorites.values())
        .some(f => f.userId === userId && f.recipeId === id);
    }

    return {
      ...recipe,
      ingredients: recipeIngredients,
      photos: recipePhotosData,
      author: author!,
      favoriteCount,
      isFavorited,
    };
  }

  async getRecipesByUser(userId: string): Promise<RecipeWithDetails[]> {
    const userRecipes = Array.from(this.recipes.values())
      .filter(r => r.userId === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const recipes = await Promise.all(userRecipes.map(r => this.getRecipe(r.id, userId)));
    return recipes.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getPublicRecipes(userId?: string): Promise<RecipeWithDetails[]> {
    const publicRecipes = Array.from(this.recipes.values())
      .filter(r => !r.isPrivate)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const recipes = await Promise.all(publicRecipes.map(r => this.getRecipe(r.id, userId)));
    return recipes.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getFavoritedRecipes(userId: string): Promise<RecipeWithDetails[]> {
    const favs = Array.from(this.favorites.values())
      .filter(f => f.userId === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const recipeIds = favs.map(f => f.recipeId);
    const recipes = await Promise.all(recipeIds.map(id => this.getRecipe(id, userId)));
    return recipes.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getSharedRecipes(email: string): Promise<RecipeWithDetails[]> {
    const shared = Array.from(this.sharedRecipes.values())
      .filter(s => s.sharedWithEmail === email)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    const recipeIds = shared.map(s => s.recipeId);
    const recipes = await Promise.all(recipeIds.map(id => this.getRecipe(id)));
    return recipes.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async createRecipe(recipe: InsertRecipe): Promise<Recipe> {
    const id = this.generateId();
    const newRecipe: Recipe = {
      id,
      ...recipe,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    this.recipes.set(id, newRecipe);
    return newRecipe;
  }

  async updateRecipe(id: string, recipe: Partial<InsertRecipe>): Promise<Recipe> {
    const existing = this.recipes.get(id);
    if (!existing) throw new Error("Recipe not found");

    const updated: Recipe = {
      ...existing,
      ...recipe,
      updatedAt: new Date(),
    };
    this.recipes.set(id, updated);
    return updated;
  }

  async deleteRecipe(id: string): Promise<void> {
    this.recipes.delete(id);
    // Delete associated data
    Array.from(this.ingredients.keys())
      .filter(key => this.ingredients.get(key)?.recipeId === id)
      .forEach(key => this.ingredients.delete(key));
    Array.from(this.favorites.keys())
      .filter(key => this.favorites.get(key)?.recipeId === id)
      .forEach(key => this.favorites.delete(key));
    Array.from(this.recipePhotos.keys())
      .filter(key => this.recipePhotos.get(key)?.recipeId === id)
      .forEach(key => this.recipePhotos.delete(key));
    Array.from(this.sharedRecipes.keys())
      .filter(key => this.sharedRecipes.get(key)?.recipeId === id)
      .forEach(key => this.sharedRecipes.delete(key));
  }

  // Ingredients
  async createIngredient(ingredient: InsertIngredient): Promise<Ingredient> {
    const id = this.generateId();
    const newIngredient: Ingredient = {
      id,
      ...ingredient,
    };
    this.ingredients.set(id, newIngredient);
    return newIngredient;
  }

  async updateIngredient(id: string, ingredient: Partial<InsertIngredient>): Promise<Ingredient> {
    const existing = this.ingredients.get(id);
    if (!existing) throw new Error("Ingredient not found");

    const updated: Ingredient = {
      ...existing,
      ...ingredient,
    };
    this.ingredients.set(id, updated);
    return updated;
  }

  async deleteIngredient(id: string): Promise<void> {
    this.ingredients.delete(id);
  }

  async deleteIngredientsByRecipe(recipeId: string): Promise<void> {
    Array.from(this.ingredients.keys())
      .filter(key => this.ingredients.get(key)?.recipeId === recipeId)
      .forEach(key => this.ingredients.delete(key));
  }

  // Favorites
  async toggleFavorite(userId: string, recipeId: string): Promise<{ isFavorited: boolean }> {
    const existing = Array.from(this.favorites.entries())
      .find(([_, f]) => f.userId === userId && f.recipeId === recipeId);

    if (existing) {
      this.favorites.delete(existing[0]);
      return { isFavorited: false };
    } else {
      const id = this.generateId();
      const newFavorite: Favorite = {
        id,
        userId,
        recipeId,
        createdAt: new Date(),
      };
      this.favorites.set(id, newFavorite);
      return { isFavorited: true };
    }
  }

  async getFavoriteCount(recipeId: string): Promise<number> {
    return Array.from(this.favorites.values())
      .filter(f => f.recipeId === recipeId)
      .length;
  }

  // Sharing
  async shareRecipe(recipeId: string, email: string): Promise<SharedRecipe> {
    const id = this.generateId();
    const newShare: SharedRecipe = {
      id,
      recipeId,
      sharedWithEmail: email,
      createdAt: new Date(),
    };
    this.sharedRecipes.set(id, newShare);
    return newShare;
  }

  // Photos
  async createRecipePhoto(photo: InsertRecipePhoto): Promise<RecipePhoto> {
    const id = this.generateId();
    const newPhoto: RecipePhoto = {
      id,
      ...photo,
      createdAt: new Date(),
    };
    this.recipePhotos.set(id, newPhoto);
    return newPhoto;
  }

  async deleteRecipePhoto(id: string): Promise<void> {
    this.recipePhotos.delete(id);
  }
}

import { db } from "./db";
import { users, recipes, ingredients, favorites, sharedRecipes, recipePhotos } from "@shared/schema";
import { eq, and, desc, sql as drizzleSql } from "drizzle-orm";

export class DrizzleStorage implements IStorage {
  // Users
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }

  async createUser(user: InsertUser): Promise<User> {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }

  // Recipes
  async getRecipe(id: string, userId?: string): Promise<RecipeWithDetails | undefined> {
    const [recipe] = await db.select().from(recipes).where(eq(recipes.id, id));
    if (!recipe) return undefined;

    const recipeIngredients = await db
      .select()
      .from(ingredients)
      .where(eq(ingredients.recipeId, id))
      .orderBy(ingredients.order);

    const recipePhotosData = await db
      .select()
      .from(recipePhotos)
      .where(eq(recipePhotos.recipeId, id));

    const [author] = await db.select().from(users).where(eq(users.id, recipe.userId));
    const favoriteCount = await this.getFavoriteCount(id);

    let isFavorited = false;
    if (userId) {
      const [fav] = await db
        .select()
        .from(favorites)
        .where(and(eq(favorites.userId, userId), eq(favorites.recipeId, id)));
      isFavorited = !!fav;
    }

    return {
      ...recipe,
      ingredients: recipeIngredients,
      photos: recipePhotosData,
      author: author!,
      favoriteCount,
      isFavorited,
    };
  }

  async getRecipesByUser(userId: string): Promise<RecipeWithDetails[]> {
    const userRecipes = await db
      .select()
      .from(recipes)
      .where(eq(recipes.userId, userId))
      .orderBy(desc(recipes.createdAt));

    const results = await Promise.all(
      userRecipes.map(r => this.getRecipe(r.id, userId))
    );
    return results.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getPublicRecipes(userId?: string): Promise<RecipeWithDetails[]> {
    const publicRecipes = await db
      .select()
      .from(recipes)
      .where(eq(recipes.isPrivate, false))
      .orderBy(desc(recipes.createdAt));

    const results = await Promise.all(
      publicRecipes.map(r => this.getRecipe(r.id, userId))
    );
    return results.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getFavoritedRecipes(userId: string): Promise<RecipeWithDetails[]> {
    const favs = await db
      .select({ recipeId: favorites.recipeId })
      .from(favorites)
      .where(eq(favorites.userId, userId));

    const results = await Promise.all(
      favs.map(f => this.getRecipe(f.recipeId, userId))
    );
    return results.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async getSharedRecipes(email: string): Promise<RecipeWithDetails[]> {
    const shared = await db
      .select({ recipeId: sharedRecipes.recipeId })
      .from(sharedRecipes)
      .where(eq(sharedRecipes.sharedWithEmail, email));

    const results = await Promise.all(
      shared.map(s => this.getRecipe(s.recipeId))
    );
    return results.filter((r): r is RecipeWithDetails => r !== undefined);
  }

  async createRecipe(recipe: InsertRecipe): Promise<Recipe> {
    const [newRecipe] = await db.insert(recipes).values(recipe).returning();
    return newRecipe;
  }

  async updateRecipe(id: string, recipe: Partial<InsertRecipe>): Promise<Recipe> {
    const [updated] = await db
      .update(recipes)
      .set({ ...recipe, updatedAt: new Date() })
      .where(eq(recipes.id, id))
      .returning();
    return updated;
  }

  async deleteRecipe(id: string): Promise<void> {
    await db.delete(recipes).where(eq(recipes.id, id));
  }

  // Ingredients
  async createIngredient(ingredient: InsertIngredient): Promise<Ingredient> {
    const [newIngredient] = await db.insert(ingredients).values(ingredient).returning();
    return newIngredient;
  }

  async updateIngredient(id: string, ingredient: Partial<InsertIngredient>): Promise<Ingredient> {
    const [updated] = await db
      .update(ingredients)
      .set(ingredient)
      .where(eq(ingredients.id, id))
      .returning();
    return updated;
  }

  async deleteIngredient(id: string): Promise<void> {
    await db.delete(ingredients).where(eq(ingredients.id, id));
  }

  async deleteIngredientsByRecipe(recipeId: string): Promise<void> {
    await db.delete(ingredients).where(eq(ingredients.recipeId, recipeId));
  }

  // Favorites
  async toggleFavorite(userId: string, recipeId: string): Promise<{ isFavorited: boolean }> {
    const [existing] = await db
      .select()
      .from(favorites)
      .where(and(eq(favorites.userId, userId), eq(favorites.recipeId, recipeId)));

    if (existing) {
      await db.delete(favorites).where(eq(favorites.id, existing.id));
      return { isFavorited: false };
    } else {
      await db.insert(favorites).values({ userId, recipeId });
      return { isFavorited: true };
    }
  }

  async getFavoriteCount(recipeId: string): Promise<number> {
    const result = await db
      .select({ count: drizzleSql<number>`count(*)::int` })
      .from(favorites)
      .where(eq(favorites.recipeId, recipeId));
    return result[0]?.count || 0;
  }

  // Sharing
  async shareRecipe(recipeId: string, email: string): Promise<SharedRecipe> {
    const [shared] = await db.insert(sharedRecipes).values({ recipeId, sharedWithEmail: email }).returning();
    return shared;
  }

  // Photos
  async createRecipePhoto(photo: InsertRecipePhoto): Promise<RecipePhoto> {
    const [newPhoto] = await db.insert(recipePhotos).values(photo).returning();
    return newPhoto;
  }

  async deleteRecipePhoto(id: string): Promise<void> {
    await db.delete(recipePhotos).where(eq(recipePhotos.id, id));
  }
}

export const storage = new DrizzleStorage();
